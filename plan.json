[
    {
        "id": 1,
        "category": "chore",
        "description": "Set up testing infrastructure and add unit tests for existing functionality",
        "steps": [
            "Create ralph_test.go file with test framework setup",
            "Add unit tests for detectBuildSystem() function covering all build system types",
            "Add unit tests for applyBuildSystemConfig() with various configuration scenarios",
            "Add unit tests for isCursorAgent() helper function",
            "Add unit tests for buildPrompt() function",
            "Add unit tests for readPlanFile() and filterPlans() functions",
            "Add integration test for plan generation workflow",
            "Update Makefile to include test coverage reporting",
            "Verify all tests pass with go test ./..."
        ],
        "expected_output": "Test suite with >80% code coverage for existing functions, all tests passing, coverage reports generated via Makefile",
        "tested": true
    },
    {
        "id": 2,
        "category": "chore",
        "description": "Refactor codebase into modular package structure for maintainability",
        "steps": [
            "Create internal/config package for Config struct and configuration logic",
            "Create internal/agent package for agent execution and communication",
            "Create internal/plan package for plan file operations (read, write, filter)",
            "Create internal/detection package for build system detection logic",
            "Create internal/prompt package for prompt building logic",
            "Move BuildSystemPresets to internal/detection/presets.go",
            "Update main.go to import and use new packages",
            "Ensure all existing tests still pass after refactoring",
            "Update imports and resolve any circular dependency issues"
        ],
        "expected_output": "Codebase organized into internal/ packages with clear separation of concerns, all existing functionality preserved, tests passing",
        "tested": true
    },
    {
        "id": 3,
        "category": "infra",
        "description": "Add YAML/JSON configuration file support for persistent settings",
        "steps": [
            "Define ConfigFile struct with fields for agent, build-system, typecheck, test, plan, progress, and custom settings",
            "Create internal/config/file.go for configuration file loading",
            "Support .ralph.yaml, .ralph.json, and ralph.config.yaml file names",
            "Implement config file discovery (current directory, then home directory)",
            "Implement config merging: file settings < environment variables < CLI flags",
            "Add -config flag to specify custom config file path",
            "Add validation for config file contents",
            "Write tests for config file loading and merging",
            "Document configuration file format in README.md"
        ],
        "expected_output": "Ralph reads settings from .ralph.yaml or .ralph.json if present, CLI flags override file settings, documented in README",
        "tested": true
    },
    {
        "id": 4,
        "category": "infra",
        "description": "Implement enhanced Environment-Aware Execution with automatic adaptation",
        "steps": [
            "Create internal/environment package for environment detection",
            "Detect CI environment (GitHub Actions, GitLab CI, Jenkins, CircleCI) via environment variables",
            "Detect available system resources (CPU cores, memory) using runtime package",
            "Detect repo size and file count to estimate project complexity",
            "Implement EnvironmentProfile struct with detected attributes",
            "Add automatic timeout adjustment based on environment (longer in CI, shorter locally)",
            "Add automatic verbosity adjustment (more verbose in CI for logs)",
            "Add parallel execution hints based on available CPU cores",
            "Implement -environment flag to override detected environment",
            "Write tests mocking various environments",
            "Add environment info to verbose output"
        ],
        "expected_output": "Ralph automatically detects and adapts to local dev, CI, and resource-constrained environments without manual configuration",
        "tested": true
    },
    {
        "id": 5,
        "category": "data",
        "description": "Implement Milestone-Based Progress Tracking system",
        "steps": [
            "Extend Plan struct to include optional 'milestone' field (string) and 'milestone_order' field (int)",
            "Create internal/milestone package for milestone management",
            "Define Milestone struct with id, name, description, criteria, and status fields",
            "Add support for milestone definitions in plan.json (separate milestones array)",
            "Implement milestone progress calculation (% of features complete per milestone)",
            "Add -milestones flag to list all milestones with progress",
            "Add -milestone <name> flag to show features for specific milestone",
            "Implement milestone completion detection and celebration message",
            "Add milestone progress to verbose output during iterations",
            "Write tests for milestone progress calculation",
            "Update README with milestone documentation"
        ],
        "expected_output": "Users can define milestones like 'API usable' or 'beta-ready', see progress toward each, and get notifications when milestones are reached",
        "tested": true
    },
    {
        "id": 6,
        "category": "other",
        "description": "Implement User Nudge Hooks for lightweight mid-run guidance",
        "steps": [
            "Create internal/nudge package for nudge system",
            "Define Nudge struct with type (constraint, preference, priority), content, and timestamp",
            "Create nudges.json file format for persistent nudges",
            "Implement file watcher to detect nudge file changes during execution",
            "Add nudge injection into agent prompts when detected",
            "Support nudge types: 'focus' (prioritize feature), 'skip' (defer feature), 'constraint' (add requirement), 'style' (coding preferences)",
            "Add -nudge flag for one-time inline nudges",
            "Add -clear-nudges flag to reset nudge file",
            "Implement nudge acknowledgment in progress.txt",
            "Write tests for nudge parsing and injection",
            "Document nudge system in README"
        ],
        "expected_output": "Users can create/edit nudges.json during a run to steer Ralph without stopping, nudges are incorporated into subsequent iterations",
        "tested": true
    },
    {
        "id": 7,
        "category": "other",
        "description": "Implement Failure Recovery Strategies for autonomous setback handling",
        "steps": [
            "Create internal/recovery package for failure handling",
            "Define failure types: test_failure, typecheck_failure, agent_error, timeout",
            "Implement failure detection from agent output and command results",
            "Create RecoveryStrategy interface with Apply() method",
            "Implement RetryStrategy: retry same feature with different prompt emphasis",
            "Implement SimplifyStrategy: break feature into smaller sub-tasks",
            "Implement RollbackStrategy: revert to last known good state via git",
            "Implement SkipStrategy: mark feature as blocked and move to next",
            "Add failure tracking in progress.txt with failure count per feature",
            "Configure max retries before strategy escalation (default: 3)",
            "Add -max-retries flag to configure retry limit",
            "Add -recovery-strategy flag to set preferred strategy (retry, simplify, rollback, skip)",
            "Write tests for each recovery strategy",
            "Log recovery actions for debugging"
        ],
        "expected_output": "Ralph automatically handles failures by retrying, simplifying tasks, rolling back, or skipping, reducing iteration failures and stuck states",
        "tested": true
    },
    {
        "id": 8,
        "category": "data",
        "description": "Implement Long-Running Goal Memory for cross-session continuity",
        "steps": [
            "Create internal/memory package for persistent memory",
            "Define Memory struct with decisions, conventions, tradeoffs, and context arrays",
            "Create .ralph-memory.json file format in project root",
            "Implement memory entry types: 'decision' (architectural choice), 'convention' (coding standard), 'tradeoff' (accepted compromise), 'context' (project knowledge)",
            "Add memory extraction from agent responses using markers like [REMEMBER:]",
            "Implement memory injection into agent prompts as context",
            "Add memory relevance scoring based on current feature category",
            "Add -show-memory flag to display stored memories",
            "Add -clear-memory flag to reset memory file",
            "Add -add-memory flag for manual memory entries",
            "Implement memory pruning for outdated entries (configurable retention)",
            "Write tests for memory storage and retrieval",
            "Document memory system in README"
        ],
        "expected_output": "Ralph remembers architectural decisions and conventions across runs, reducing repetitive guidance and maintaining consistency",
        "tested": true
    },
    {
        "id": 9,
        "category": "other",
        "description": "Implement Smart Scope Control for automatic feature management",
        "steps": [
            "Create internal/scope package for scope management",
            "Define ScopeConstraints struct with max_iterations, max_time, quality_threshold fields",
            "Add scope constraints to config file format",
            "Implement iteration budget tracking per feature",
            "Implement time budget tracking (optional deadline)",
            "Add feature complexity estimation based on step count and description",
            "Implement automatic feature deferral when budget exceeded",
            "Add deferred features list in plan.json (new 'deferred' boolean field)",
            "Implement feature simplification suggestions when scope is tight",
            "Add -scope-limit flag for max iterations per feature",
            "Add -deadline flag for time-based scope control",
            "Add scope status to progress output",
            "Write tests for scope calculation and deferral logic",
            "Document scope control in README"
        ],
        "expected_output": "Ralph automatically defers or simplifies features when constraints are reached, preventing over-building while pushing toward completion",
        "tested": true
    },
    {
        "id": 10,
        "category": "other",
        "description": "Implement Adaptive Plan Replanning for dynamic plan adjustment",
        "steps": [
            "Create internal/replan package for replanning logic",
            "Define ReplanTrigger interface for conditions that trigger replanning",
            "Implement TestFailureTrigger: replan when tests fail repeatedly",
            "Implement RequirementChangeTrigger: detect plan.json manual edits",
            "Implement BlockedFeatureTrigger: replan when feature is blocked",
            "Create ReplanStrategy interface with GenerateNewPlan() method",
            "Implement IncrementalReplan: adjust remaining features based on completed work",
            "Implement agent-based replanning: send current state to agent for new plan",
            "Add plan versioning (backup old plans as plan.json.bak.N)",
            "Add -auto-replan flag to enable automatic replanning (default: prompt user)",
            "Add -replan flag to manually trigger replanning",
            "Implement plan diff display showing changes",
            "Write tests for replan triggers and strategies",
            "Document replanning system in README"
        ],
        "expected_output": "Ralph dynamically adjusts the remaining plan when tests fail or requirements change, self-correcting without full restart",
        "tested": true
    },
    {
        "id": 11,
        "category": "other",
        "description": "Implement Outcome-Focused Validation beyond tests and type checks",
        "steps": [
            "Create internal/validation package for advanced validation",
            "Define Validator interface with Validate() method returning ValidationResult",
            "Implement EndpointValidator: verify API endpoints respond correctly via HTTP calls",
            "Implement CLIValidator: verify CLI commands work end-to-end",
            "Implement OutputValidator: check for expected output patterns",
            "Add validation definitions to plan.json features (new 'validations' array field)",
            "Support validation types: http_get, http_post, cli_command, file_exists, output_contains",
            "Implement validation runner that executes all validations for a feature",
            "Add validation results to progress.txt",
            "Add -validate flag to run validations for all completed features",
            "Add -validate-feature <id> flag to validate specific feature",
            "Implement validation timeout and retry logic",
            "Write tests for each validator type",
            "Document validation system in README"
        ],
        "expected_output": "Ralph can validate higher-level outcomes like 'API responds correctly' or 'CLI works end-to-end' beyond just tests and type checks",
        "tested": true
    },
    {
        "id": 12,
        "category": "infra",
        "description": "Implement Goal-Oriented Project Outcomes with automatic plan decomposition",
        "steps": [
            "Create internal/goals package for goal management",
            "Define Goal struct with description, success_criteria, and generated_plan fields",
            "Create goals.json file format for high-level goal definitions",
            "Implement goal-to-plan decomposition using AI agent",
            "Add -goal flag to specify a high-level goal as string",
            "Add -goals-file flag to specify goals.json path",
            "Implement goal analysis prompt that extracts requirements",
            "Generate categorized plan items from goal analysis",
            "Add dependency detection between generated plan items",
            "Implement goal progress tracking (% of generated plan complete)",
            "Add -goal-status flag to show progress toward goals",
            "Support multiple concurrent goals with priority ordering",
            "Write tests for goal parsing and plan generation",
            "Document goal system in README"
        ],
        "expected_output": "Users can specify high-level goals like 'add payments' and Ralph automatically decomposes them into actionable plans and iterations",
        "tested": true
    },
    {
        "id": 13,
        "category": "infra",
        "description": "Implement Multi-Agent Collaboration for parallel AI coordination",
        "steps": [
            "Create internal/multiagent package for agent coordination",
            "Define AgentRole enum: implementer, tester, reviewer, refactorer",
            "Define AgentConfig struct with role, command, and specialization fields",
            "Support multiple agent configurations in config file",
            "Implement AgentOrchestrator to coordinate multiple agents",
            "Create work distribution logic: implementer creates, tester validates, reviewer checks quality",
            "Implement agent communication via shared context files",
            "Add parallel execution support for independent agent tasks",
            "Implement result aggregation from multiple agents",
            "Add conflict resolution when agents disagree",
            "Add -agents flag to specify agent configuration file",
            "Add -parallel-agents flag to set max concurrent agents",
            "Implement agent health monitoring and failover",
            "Write tests for orchestration and coordination logic",
            "Document multi-agent system in README"
        ],
        "expected_output": "Ralph can coordinate multiple AI agents (implementer, tester, reviewer) working in parallel to improve quality and speed",
        "tested": true
    },
    {
        "id": 14,
        "category": "ui",
        "description": "Implement enhanced CLI output with progress visualization",
        "steps": [
            "Create internal/ui package for output formatting",
            "Implement progress bar for iteration progress",
            "Implement spinner for long-running operations",
            "Add colored output support (success=green, error=red, warning=yellow)",
            "Implement -no-color flag to disable colored output",
            "Add summary dashboard at end of run showing features completed, time elapsed, failures recovered",
            "Implement real-time status line showing current feature and progress",
            "Add -quiet flag for minimal output (errors only)",
            "Add -json-output flag for machine-readable output",
            "Implement log levels (debug, info, warn, error) with -log-level flag",
            "Write tests for output formatting",
            "Ensure CI compatibility (detect non-TTY and adjust output)"
        ],
        "expected_output": "Ralph provides rich CLI output with progress bars, colors, and summary dashboards while supporting quiet/JSON modes for automation",
        "tested": true
    },
    {
        "id": 15,
        "category": "chore",
        "description": "Comprehensive documentation and example project creation",
        "steps": [
            "Create examples/ directory with sample projects",
            "Create examples/simple-api/ with a basic API project and plan.json",
            "Create examples/fullstack-app/ with frontend+backend example",
            "Create examples/cli-tool/ showing CLI development workflow",
            "Write CONTRIBUTING.md with development guidelines",
            "Create docs/ARCHITECTURE.md explaining package structure",
            "Create docs/CONFIGURATION.md with all config options",
            "Create docs/FEATURES.md detailing each feature",
            "Add inline code documentation (godoc comments) to all exported functions",
            "Create troubleshooting guide in docs/TROUBLESHOOTING.md",
            "Add FAQ section to README",
            "Generate and include architecture diagram"
        ],
        "expected_output": "Comprehensive documentation with examples, architecture docs, and troubleshooting guides enabling easy onboarding and contribution",
        "tested": true
    },
    {
        "id": 16,
        "category": "chore",
        "description": "Plan Step Refinement",
        "steps": [
            "If a plan description has 'and', in it consider if it is actually multiple features and split them into separate plan items",
            "Step features can be long and complex, consider if it is actually multiple features and split them into separate plan items, for example some steps > 9 steps"
        ],
        "expected_output": "Plan items are self-contained and implementable, and are not too complex",
        "tested": true
    },
    {
        "id": 17,
        "category": "chore",
        "description": "rewrite the plan.json not just analyse it",
        "steps": [
            "rewrite the plan.json not just analyse it as we did in feature 16"
        ],
        "expected_output": "The plan.json is rewritten with the suggested refinements",
        "tested": true
    },
    {
        "id": 18,
        "category": "chore",
        "description": "analyse the feature flags that modify the plan.json",
        "steps": [
            "there are a lot of feature flags that sound similar. analyse them and make sure they are not redundant or conflicting or similar in functionality",
            "for example -analyze-plan and -refine-plan are similar, sound similar",
            "if you identify a redundant or conflicting or similar in functionality append to the plan.json as work items to be completed",
            "Ensure you detail the code changes that need to be made to the feature flags that are redundant or conflicting or similar in functionality so that the code can be updated/deleted in future iterations"
        ],
        "expected_output": "The code is analysed and the feature flags that are redundant or conflicting or similar in functionality are appended to the plan.json as work items to be completed",
        "tested": true
    },
    {
        "id": 19,
        "category": "chore",
        "description": "Consolidate redundant -status flag with -list-tested and -list-untested",
        "steps": [
            "In ralph.go, the -status flag functionality (ListStatus) duplicates -list-tested + -list-untested combined",
            "Consider deprecating -status flag with a warning message pointing users to use -list-tested and/or -list-untested",
            "Alternatively, rename -status to -list-all for clarity and keep it as a convenience alias",
            "Update help text in flag.Usage to clarify the relationship between these three flags",
            "Update docs/CONFIGURATION.md to document the deprecation or clarification",
            "Add unit tests to verify deprecation warning is shown when -status is used"
        ],
        "expected_output": "The -status flag is either deprecated with clear guidance or renamed for clarity, reducing user confusion",
        "tested": true
    },
    {
        "id": 20,
        "category": "chore",
        "description": "Merge -goal-status and -list-goals into unified goal display",
        "steps": [
            "In ralph.go handleGoalCommands(), -goal-status shows progress bars while -list-goals shows a basic list",
            "These two commands serve nearly identical purposes and could confuse users",
            "Option A: Merge into single -goals flag that shows both list and progress (like -milestones does)",
            "Option B: Rename -list-goals to -goals and have -goal-status as an alias or verbose mode",
            "Update flag definitions in parseFlags() to implement the chosen option",
            "Update Config struct in internal/config/config.go to remove redundant field",
            "Update help text and docs/CONFIGURATION.md",
            "Add migration note for users using the deprecated flag"
        ],
        "expected_output": "Goal-related display commands are unified into a single intuitive flag, matching the -milestones pattern",
        "tested": true
    },
    {
        "id": 21,
        "category": "chore",
        "description": "Clarify naming distinction between -analyze-plan and -refine-plan",
        "steps": [
            "The flags -analyze-plan (read-only) and -refine-plan (writes changes) are related but distinct",
            "Is the difference between the two flags is one writes the other proposes changes but does not write them?",
            "can a temporary file be used to store the proposed changes so that the user can review them before committing them to the plan.json? - analyze-plan",
            "then refine pecomes the write operation",
            "Add clearer help text distinguishing that -analyze-plan is read-only while -refine-plan modifies files",
            "Consider renaming -refine-plan to -apply-refinements or -fix-plan to make the modification aspect clearer",
            "If renaming, add backwards compatibility alias for -refine-plan",
            "Update flag.Usage in ralph.go to group these flags together with clear descriptions",
            "Update docs/CONFIGURATION.md with clearer documentation",
            "Consider adding a -dry-run mode to -refine-plan that shows changes without writing"
        ],
        "expected_output": "The distinction between analysis-only and modification flags is clear to users",
        "tested": true
    },
    {
        "id": 22,
        "category": "chore",
        "description": "Improve documentation for failure-handling flag pairs",
        "steps": [
            "The flags -max-retries/-recovery-strategy relate to per-feature recovery",
            "The flags -replan-threshold/-replan-strategy relate to whole-plan replanning",
            "These two systems work at different levels but have similar naming patterns that could confuse users",
            "Add a clear section in flag.Usage explaining the two-tier failure handling (recovery vs replanning)",
            "Group recovery flags together and replan flags together in help output",
            "Consider adding --help-recovery and --help-replan flags for detailed documentation",
            "Update docs/FEATURES.md with a diagram showing how recovery escalates to replanning",
            "Add examples in docs/TROUBLESHOOTING.md showing when to use each system"
        ],
        "expected_output": "Users clearly understand the difference between per-feature recovery and plan-level replanning",
        "tested": true
    },
    {
        "id": 23,
        "category": "chore",
        "description": "Add flag grouping and categorization to help output",
        "steps": [
            "The current flag.Usage output lists all 50+ flags in a single block which is overwhelming",
            "Group flags by category: Core, Plan Management, Recovery, Replanning, Memory, Nudges, Goals, Multi-Agent, UI, etc.",
            "Implement a custom usage printer that organizes flags into logical sections",
            "Add short descriptions for each category before its flags",
            "Consider adding -help-<category> flags for detailed help on specific features (e.g., -help-goals)",
            "Update flag.Usage function in ralph.go parseFlags()",
            "Ensure the grouped help output is well-formatted and easy to scan"
        ],
        "expected_output": "Help output is organized into clear categories making it easier for users to find relevant flags",
        "tested": true
    }
]